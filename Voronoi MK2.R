library(tidyverse)
library(sf)
library(lwgeom)
library(nngeo)

#points_x = numeric vector of x/Longitude values
#points_y = numeric vector of y/Latitude values
#bounds = sf polygon of the bounding region

voronoi <- function(points_x, points_y, bounds) {
  
  #Force polygon boundary to clockwise:
  bounds <- st_force_polygon_cw(bounds)
  
  #process coordinate vectors into sf format
  pre_points <- 
    map(1:length(points_x), function(x) st_point(c(points_x[x], points_y[x]))) %>% 
    st_sfc()
  
  
  #filter out points that are not contained within the boundary
  not_contained <- 
    st_contains(bounds, pre_points, sparse = FALSE) %>% 
    `!`() %>% 
    which()
  
  if (length(not_contained) > 0) {
      points_global <- tibble(x = points_x[-not_contained], y = points_y[-not_contained]) %>%
          unique()  
  } else {
      points_global <- tibble(x = points_x, y = points_y) %>%
          unique()
  }
  
  
  
  #mathematical formula for the line that is generated when two circles (with centers at point1 and point2) of same radius intersect
  intersection <- function(point1, point2) {
    x1 <- point1[1]
    y1 <- point1[2]
    x2 <- point2[1]
    y2 <- point2[2]
    
    body <- 
      str_c("(((", x1, ")^2 - (", x2, ")^2) + ((", y1, ")^2 - (", y2, ")^2) - 2*x*(", x1, " - ", x2, ")) / (2*(", y1, " - ", y2, "))", sep = "")
    
    eval(parse(text = paste('f <- function(', alist(x = x), ') { return(' , body , ')}', sep='')))
    
    return(f)
    
    
  }
  
  
  
  #for each point, create and nest the lines generated by the "intersection" function
  #between that point and every other point
  dat <- 
    map(1:nrow(points_global), function(x) {
      points[x,] %>%
        as.matrix() %>%
        st_point()
    }) %>%
    cbind() %>%
    data.frame() %>%
    st_sf() %>%
    as_tibble() %>%
    `names<-`("points") %>%
    mutate(rown = row_number())
  
  dat <- 
    dat %>%
    mutate(others = map(rown, function(x) {
      dat %>%
        filter(rown != x) %>%
        mutate(reference = dat %>%
                 filter(rown == x) %>%
                 pluck("points"),
               intersect_y = pmap(list(reference, points), function(x, y) {
                 intersection(x, y)
               })) %>%
        select(points, intersect_y)
    })) %>%
    select(-rown)
  
  
  
  
  
  
  #find maximum values of the bounded space, so that the intersection lines
  #are guaranteed to sweep through the entire space
  tmp_mat <- 
    as.matrix(bounds)
  
  xmin <- 
    tmp_mat %>%
    `[`(,1) %>%
    min() %>%
    `-`(1)
  
  xmax <- 
    tmp_mat %>%
    `[`(,1) %>%
    max() %>%
    `+`(1)
  
  ymax <- 
    tmp_mat %>%
    `[`(,2) %>%
    max() %>%
    `+`(1)
  
  ymin <- 
    tmp_mat %>%
    `[`(,2) %>%
    max() %>%
    `-`(1)
  
  
  
  #draw linestrings of intersection lines
  dat <- 
    dat %>%
    mutate(others = map(1:nrow(dat), function(z) {
      dat$others[[z]] %>%
        mutate(line_segment = map(1:nrow(dat$others[[z]]), function(y) {
          
          #control for infinite slope of intersection line
          #i.e. reference point and "other" point have identical Latitudes
          if (dat$others[[z]]$points[[y]][2] == points_global$y[z]) {
            x_int <- (dat$others[[z]]$points[[y]][1] + points_global$x[z]) / 2
            
            matrix(c(x_int, x_int, ymax, ymin), nrow = 2, ncol = 2) %>%
              st_linestring(dim = "XY")
          } else {
            y_right <- 
              dat$others[[z]]$intersect_y[[y]] %>%
              do.call(list(xmax))
            
            y_left <- 
              dat$others[[z]]$intersect_y[[y]] %>%
              do.call(list(xmin))
            
            #this must exceed the x limits of the boundary
            matrix(c(xmin, xmax, y_left, y_right), nrow = 2, ncol = 2) %>%
              st_linestring(dim = "XY")  
          }
        })) %>%
        select(line_segment)
    }))
  
  #split boundary polygon into individual line segments
  #this allows us to determine where exactly an intersection line crosses the boundary
  bounding_lines <- st_segments(bounds, progress = FALSE)
  
  
  
  
  
  dat %>%
    mutate(polys = map2(points, others, function(a, b) {
      
      #draw line_segment radiating from reference point at the angle of 0
      zero_theta <- 
        c(a[1], a[2],
          xmax, a[2]) %>%
        matrix(ncol = 2, byrow = TRUE) %>%
        st_linestring()
      
      #which line segment, that intersects zero_theta, is closest to reference point?;
      #possibilities include the boundary
      #If nearest line segment is part of the boundary, an integer is recorded that
      #identifies which portion of the boundary was intersected.
      zero_theta_bound <- 
        b %>%
        mutate(zero_theta_int = map_lgl(line_segment, function(x) {
          st_intersects(x, zero_theta, sparse = FALSE)[1,1]
        })) %>%
        filter(zero_theta_int) %>%
        mutate(int_dist = map_dbl(line_segment, function(x) {
          st_intersection(x, zero_theta) %>%
            st_distance(a)
        })) %>%
        bind_rows(
          tibble(
            line_segment = list(integer(0)),
            zero_theta_int = TRUE,
            int_dist = st_intersection(st_cast(bounds, "MULTILINESTRING"), zero_theta) %>%
              st_distance(a) %>%
              `[`(1,1)
          )
        ) %>%
        arrange(int_dist) %>%
        pluck("line_segment") %>%
        `[[`(1)
      
      
      current_segment <- zero_theta_bound
      vertices <- vector("list", 0)
      
      #This loop travels counter-clockwise from zero_theta_bound and records
      #all the intersection points.
      #The infinite loop ends when the same vertex is recorded twice.
      #This bounds the polygon to create the Voronoi tessellation for the reference point.
      while (1==1) {
        if (!is.integer(current_segment)) {
          tmp <- 
            b %>%
            filter(map_lgl(line_segment, function(x) {
              x != current_segment
            })) %>%
            mutate(int = map(line_segment, function(x) {
              st_intersection(x, current_segment)
            }),
            int = st_sfc(int)) %>%
            bind_rows(
              tibble(line_segment = st_intersects(bounding_lines, current_segment, sparse = FALSE) %>%
                       which() %>%
                       map(function(x) x)) %>%
                mutate(int = map(line_segment, function(x) {
                  st_intersection(bounding_lines[[x]], current_segment)
                }) %>%
                  st_sfc())
            ) %>%
            filter(map_lgl(int, function(x) {
              x %>%
                as.double() %>%
                length() %>%
                `>`(0)
            })) %>%
            filter(map_lgl(int, function(x) {
              #first iteration
              if (length(vertices) == 0) {
                #First intersection on zero_theta_bound must be have a greater Latitude
                #than the intersection with the zero_theta line
                #to guarantee that the algorithm crawls counter-clockwise.
                x[2] > a[2]
              } else {
                #Removes self-same intersection.
                if (st_distance(vertices[[length(vertices)]], x) == 0) {
                  FALSE
                } else {
                  #Creates temporary polygon to judge if the addition of the intersection
                  #maintains a counter-clockwise direction.
                  list(a, vertices[[length(vertices)]], x, a) %>%
                    st_sfc() %>%
                    st_combine() %>%
                    st_cast("POLYGON") %>%
                    st_is_polygon_cw() %>%
                    `!`()
                }
              }
            }))
          
          #For first iteration:
          if (length(vertices) == 0) {
            first_int <- st_intersection(zero_theta_bound, zero_theta)
            
            #Generate distances from intersections to zero_theta-intersection
            #along zero_theta_bound.
            tmp <- 
              tmp %>%
              mutate(dist = map_dbl(int, function(x) {
                st_distance(x, first_int)[1,1]
              })) %>%
              arrange(dist)
            
            #For other iterations:
          } else {
            #Generate distances from intersections to previous vertex
            #along current line segment.
            tmp <- 
              tmp %>%
              mutate(dist = map_dbl(int, function(x) {
                st_distance(x, vertices[[length(vertices)]])[1,1]
              })) %>%
              arrange(dist)
          }
          
          #Intersection of shortest distance in counter-clockwise direction
          #is the next vertex in the Voronoi polygon.
          current_segment <- tmp$line_segment[[1]]
          vertices <- append(vertices, list(tmp$int[[1]]))
        } else {
          #For if the previous vertex is on the boundary.
          if (length(current_segment) == 0) {
            seg_inds <- 
              st_intersects(bounding_lines, zero_theta, sparse = FALSE) %>%
              which()
            
            sub_ind <- 
              bounding_lines[seg_inds] %>%
              st_distance(a) %>%
              which.min()
            
            ind <- seg_inds[sub_ind]
            
            #rearrange bounding lines so that current segment is at index 1
            order_border <- bounding_lines[c(ind:1, length(bounding_lines):(ind + 1))]
            
            ints <- 
              map_df(b$line_segment, function(y) {
                tibble(line_segment = list(y),
                       int_ind = st_intersects(order_border, y, sparse = FALSE) %>% which()) %>%
                  mutate(int = map(int_ind, function(x) {
                    st_intersection(order_border[[x]], y)
                  }) %>%
                    st_sfc())
              })
            
            
            #Establish first true vertex, that where the polygon jumps from boundary
            #line segments to intersection line segments.
            final_vert <- 
              ints %>% 
              arrange(int_ind) %>% 
              filter(st_distance(int, st_intersection(bounding_lines[[ind]], zero_theta)) != 0) %>%
              group_by(int_ind) %>%
              nest() %>%
              pluck("data") %>%
              `[[`(1) %>%
              mutate(dist = map_dbl(int, function(z) {
                st_distance(z, a)
              })) %>%
              arrange(dist) %>%
              `[`(1,)
            
            current_segment <- final_vert$line_segment[[1]]
            vertices <- append(vertices, list(final_vert$int[[1]]))
          } else {
            #Append to "vertices" all intersections between that vertex which began this iteration
            #and "final_vert", the last vertex along this segment of the boundary.
            
            
            order_border <- bounding_lines[c(current_segment:1, length(bounding_lines):(current_segment + 1))]
            
            ints <- 
              map_df(b$line_segment, function(y) {
                tibble(line_segment = list(y),
                       int_ind = st_intersects(order_border, y, sparse = FALSE) %>% which()) %>%
                  mutate(int = map(int_ind, function(x) {
                    st_intersection(order_border[[x]], y)
                  }) %>%
                    st_sfc())
              })
            
            pre_final_vert <- 
              ints %>% 
              arrange(int_ind) %>% 
              filter(st_distance(int, vertices[[length(vertices)]]) != 0) %>%
              group_by(int_ind) %>%
              nest() %>%
              mutate(data = map(data, function(z) {
                z %>%
                  mutate(dist = st_distance(int, a)) %>%
                  arrange(dist) %>%
                  `[`(1,)
              })) %>%
              unnest(cols = c(data))
            
            if (pre_final_vert$int_ind[1] == 1) {
              if (st_distance(st_point(order_border[[1]][1,]), vertices[[length(vertices)]]) <
                  st_distance(st_point(order_border[[1]][1,]), pre_final_vert$int[[1]])) {
                final_vert <- pre_final_vert[2,]
                
                sub_verts <- vector("list", length = 0)
                
                for (i in 1:(final_vert$int_ind - 1)) {
                  sub_verts <- append(sub_verts, list(st_intersection(order_border[[i]], order_border[[i+1]])))
                }
                
                sub_verts <- append(sub_verts, list(final_vert$int[[1]]))
                
                current_segment <- final_vert$line_segment[[1]]
                vertices <- append(vertices, sub_verts)
                
              } else {
                current_segment <- pre_final_vert$line_segment[[1]]
                vertices <- append(pre_final_vert$int[[1]])
                
              }
            } else {
              final_vert <- pre_final_vert[1,]
              
              sub_verts <- vector("list", length = 0)
              
              for (i in 1:(final_vert$int_ind - 1)) {
                sub_verts <- append(sub_verts, list(st_intersection(order_border[[i]], order_border[[i+1]])))
              }
              
              sub_verts <- append(sub_verts, list(final_vert$int[[1]]))
              
              current_segment <- final_vert$line_segment[[1]]
              vertices <- append(vertices, sub_verts)
            }
            
            
            
          }
        }
        if ((length(vertices) >= 3) & (st_distance(vertices[[1]], vertices[[length(vertices)]]) == 0)) {
          break
        }
      }
      vertices %>%
        st_sfc() %>%
        st_combine() %>%
        st_cast("POLYGON") %>%
        `[[`(1)
    })) %>%
    select(-others) %>%
    mutate(polys = st_sfc(polys))
}



